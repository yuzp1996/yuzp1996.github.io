## 深入浅出Mysql书摘

### 操纵
```
show databases;

use yutest;

show tables;

展示表
desc yutable;
详细展示表
show create table yute \G

```

### DDL
```
创表
create table yute (name varchar(10),age int);
删表
drop table yute;
改表
alter table yutable modify name varchar(20);
alter table yutable modify age int(10) first
alter table yutable add column age int(10);
alter table yutable drop column age;
```

#### DML 增删改记录
```
insert into yutable(class,age,sex)values(1,1,1);
update yutable set age = 1 where class = 2;
delete from yutable where class = 1
```

####查询数据
```
select distinct class from yutable;

排序限制
select * from yutable order by sex limit 5;
select * from yutable order by sex limit 1,2;

 desc是descend 降序意思 
    asc 是ascend 升序意思
    sql = "select 表内容名    from   数据库表名 Putout=true order by 读取的排序表名 asc"
例如
sql = "select  *  from   user   where  Putout=true   order by time    desc"    //按最新时间来排序
sql = "select  *  from   user   where  Putout=true   order by time    asc"      //按早时间来排序


聚合
mysql> select count(1) from yutable;

mysql> select count(1) from yutable;
+----------+
| count(1) |
+----------+
|        5 |
+----------+

select class,count(1) from yutable group by class;

select class,count(1) from yutable group by class with rollup; 会计算出总数

select age,count(1) from yutable group by age having age > 20;

select max(age),min(age),sum(age) from yutable;



表连接    

表连接分为内连接和外连接，它们之间的最主要区别是內连接仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录

内连接
select 1yutable.class,yutable.age from 1yutable,yutable where 1yutable.age = yutable.class;

外连接有分为左连接和右连接
mysql> select * from yutable right join 1yutable on yutable.class = 1yutable.age;
+-------+------+------+------+-------+------+
| class | age  | sex  | age  | class | sex  |
+-------+------+------+------+-------+------+
|    33 |  223 |   23 |   33 |    21 |   22 |
|   323 |   43 |   22 |  323 |   221 |   22 |
|  NULL | NULL | NULL |   23 |    32 |   23 |
|  NULL | NULL | NULL |  231 |    32 |   23 |
|  NULL | NULL | NULL |   31 |    32 |  223 |
+-------+------+------+------+-------+------+

子查询
select class from yutable where class in(select age from 1yutable);

记录联合 (两个表的数据按照一定的查询条件查询出来后，将结果合并, 到一起显示出来需要用 union 和 union all 关键字来实现这样的功能,
    UNION ALL 是把结果集直接合并在一起，而 UNION 是将 UNION ALL 后的结果进行一次 DISTINCT，去除重复记录后的结果)

select * from yutable union select * from 1yutable;

```

#### DCL语句

grant select,insert on sakila.* to ‘z1’@’localhost’ identified by ‘123’;
在数据库sakila的所有记录给zi用户，密码是123

revoke insert on sakila.* from ‘z1’@’localhost’;
由于权限变更，需要将 z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作：


#### 查看帮助

？contents
？show
？create


```
mysql> select if(salary>2000,'high','low') from salary;
+------------------------------+
| if(salary>2000,'high','low') |
+------------------------------+
| low |
| low |
| high |
| high |
| high |
+------------------------------+
5 rows in set (0.01 sec)
```

查看用户    
> select user();

查看表
>show table status;



当前日期
> select curdate();

将表 ai 从 MyISAM 存储引擎修改成 InnoDB 存储引擎：
>alter table ai engine = innodb;


数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。

　 原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

　 一致性：指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。

　 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

　 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

查看所有可用的字符集的命令是

show character set;

创建索引（在1yutable表做的class上创建索引yuindex）
mysql> create index yuindex on 1yutable (class); 
查看索引
```
mysql> explain select * from 1yutable where class = 1 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: 1yutable
   partitions: NULL
         type: ref
possible_keys: yuindex
          key: yuindex
      key_len: 5
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```
可以看到 possible_keys: yuindex     key: yuindex 索引被使用
设计索引的原则

*最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列

*使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例 如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M” 和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。

*使用短索引。如果有一个 CHAR(200)列，如果在前 10 个或 20 个字符内，多数值是惟一 的， 那么就不要对整个列进行索引。 对前10个或20个字符进行索引能够节省大量索引空间， 也可能会使查询更快

views视图

创建视图
 create or replace view firstview as select class,age from 1yutable;
查看视图
 show table status like 'firstview' \G;

## SQL优化
### 通过 show status 命令了解各种 SQL 的执行频率

 show status like 'Com_%';

 Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

Com_select：执行 select 操作的次数，一次查询只累加 1。
Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。
Com_update：执行 UPDATE 操作的次数。
Com_delete：执行 DELETE 操作的次数
通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询 操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行 次数的计数，不论提交还是回滚都会进行累加。

对于事务型的应用，通过 Com_commit 和 Com_rollback可以了解事务提交和回滚的情况， 对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。 此外，以下几个参数便于用户了解数据库的基本情况。

Connections：试图连接 MySQL 服务器的次数。
Uptime：服务器工作时间。
Slow_queries：慢查询的次数。

### 定位执行效率较低的 SQL 语句
通过慢查询日志定位那些执行效率较低的 SQL 语句

### 通过 EXPLAIN 分析低效 SQL 的执行计划上

### 确定问题并采取相应的优化措施

经过以上步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措 施，进行优化提高执行的效率。 在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的 year 字段创建索引，具体如下：

mysql> create index ind_sales2_year on sales2(year);
Query OK, 1000 rows affected (0.03 sec)
Records: 1000 Duplicates: 0 Warnings: 0
创建索引后，再看一下这条语句的执行计划，具体如下：




****
****
# 第一章 SQL基础

SQL 语句主要可以划分为以下 3 个类别。




|特性  |DDL |DML |DCL|
|---| --- | ---|---|
|定义|数据定义语言|数据操纵语句|数据控制语句|
|作用|定义了不同的数据段、数据库、表、列、索引等数据库对象的定义|用于添加、删除、更新和查询数据库记录，并检查数据完整性|数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别|
|关键字|create、drop、alter等。| insert、delete、udpate 和select 等。|grant、revoke|
|特性|DDL 语句更多的被数据库管理员（DBA）所使用|DML 只是对表内部数据的操作||

*****
### 关键语法

>CREATE DATABASE dbname;

[可能出现的问题](http://blog.sina.com.cn/s/blog_7d553bb50102w9rb.html)

>show databases;

安装MySQL 时系统自动创建的，其各自功能如下。

|表名|information_schema|cluster|mysql|test|
|----|----|----|----|----|
|功能|主要存储了系统中的一些数据库对象信息。比如用户表信息、列信息、权限信息、字符集信息、分区信息等。|存储了系统的集群信息|存储了系统的用户权限信息。|系统自动创建的测试数据库，任何用户都可以使用|


> USE dbname;

> show tables;

删库
>drop database dbname;

在数据库中创建一张表的基本语法如下：

```
CREATE TABLE tablename (column_name_1 column_type_1 constraints，column_name_2  column_type_2  constraints ， ……column_name_n  column_type_n
constraints）

实例	>create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));

```

表创建完毕后，如果需要查看一下表的定义，可以使用如下命令：

>DESC tablename

```
mysql> desc emp;
+----------+---------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+----------+---------------+------+-----+---------+-------+
| ename | varchar(10) | YES | | | |
| hiredate | date | YES | | | |
| sal | decimal(10,2) | YES | | | |
| deptno | int(2) | YES | | | |
+----------+---------------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

详细：更详细，比如存储引擎，字符集

>show create table emp \G;

```
mysql> show create table emp \G;
*************************** 1. row ***************************
Table: emp
Create Table: CREATE TABLE `emp` (
`ename` varchar(20) DEFAULT NULL,
`hiredate` date DEFAULT NULL,
`sal` decimal(10,2) DEFAULT NULL,
`deptno` int(2) DEFAULT NULL,
```


删除表

>DROP TABLE tablename


*****

#### 在大多数情况下，表结构的更改一般都使用 alter table 语句，以下是一些常用的命令。

（1） 修改表类型，语法如下：

>ALTER TABLE tablename MODIFY [COLUMN] column_definition [FIRST | AFTER col_name]

修改表 emp 的 ename 字段定义，将 varchar(10)改为 varchar(20)

```alter table emp modify ename varchar(20);```

（2）增加表字段，语法如下：

>ALTER TABLE tablename ADD [COLUMN] column_definition [FIRST | AFTER col_name]

例如，表 emp 上新增加字段 age，类型为 int(3)

```alter table emp add column age int(3);```

（3）删除表字段，语法如下：

>ALTER TABLE tablename DROP [COLUMN] col_name

例如，将字段 age 删除掉：

mysql> alter table emp drop column age;


注意：change 和 modify都可以修改表的定义，不同的是 change 后面需要写两次列名，不方便。
但是 change 的优点是可以修改列名称，modify则不能。


（5）修改字段排列顺序。

前面介绍的的字段增加和修改语法（ADD/CNAHGE/MODIFY）中，都有一个可选项 first|after
column_name，这个选项可以用来修改字段在表中的位置，默认 ADD 增加的新字段是加在
表的最后位置，而 CHANGE/MODIFY 默认都不会改变字段的位置。

例如，将新增的字段 birth date 加在 ename 之后：

>alter table emp add birth date after ename;

修改字段 age，将它放在最前面：

>mysql> alter table emp modify age int(3) first;

（6）表改名，语法如下：

>ALTER TABLE tablename RENAME [TO] new_tablename

例如，将表 emp 改名为 emp1，命令如下：

>mysql> alter table emp rename emp1;

*****

### DML 操作是指对数据库中表记录的操作， 主要包括表记录的插入 （insert） 、 更新 （update） 、删除（delete）和查询（select） ，是开发人员日常使用最频繁的操作。


### 1插入记录

>INSERT INTO tablename (field1,field2,……fieldn) VALUES(value1,value2,……valuesn);

实例：
>> insert into emp (ename,hiredate,sal,deptno) values('zzx1','2000-01-01','2000',1);

查看
>select * from emp

### 更新记录

>UPDATE tablename SET field1=value1，field2.=value2，……fieldn=valuen [WHERE CONDITION]

实例
> update emp set sal=4000 where ename='lisa';


update 命令可以同时更新多个表中数据，语法如下：

>UPDATE t1,t2…tn set t1.field1=expr1,tn.fieldn=exprn [WHERE CONDITION]

实例

>update  emp  a,dept b  set  a.sal=a.sal*b.deptno,b.deptname=a.ename  where
a.deptno=b.deptno;

多表更新的语法更多地用在了根据一个表的字段，来动态的更新另外一个表的字段



#### 删除记录

>DELETE FROM tablename [WHERE CONDITION]

例如，在 emp 中将 ename 为‘dony’的记录全部删除，命令如下：

> delete from emp where ename='dony';


在 MySQL 中可以一次删除多个表的数据，语法如下：
DELETE t1,t2…tn FROM t1,t2…tn [WHERE CONDITION]

> delete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;

不管是单表还是多表， 不加 where 条件将会把表的所有记录删除， 所以操作时一定要小心。


#### 查询记录

>SELECT * FROM tablename [WHERE CONDITION]


```
1）查询不重复的记录。
有时需要将表中的记录去掉重复后显示出来，可以用 distinct 关键字来实现：
mysql> select ename,hiredate,sal,deptno from emp;
+--------+------------+---------+--------+
| ename | hiredate | sal | deptno |
+--------+------------+---------+--------+
| zzx | 2000-01-01 | 2000.00 | 1 |
| lisa | 2003-02-01 | 4000.00 | 2 |
| bjguan | 2004-04-02 | 5000.00 | 1 |
+--------+------------+---------+--------+
3 rows in set (0.00 sec)
mysql> select distinct deptno from emp;
+--------+
| deptno |
+--------+
| 1 |
| 2 |
+--------+
2 rows in set (0.00 sec)
```

> select * from emp where deptno=1;

（3）排序和限制。
我们经常会有这样的需求， 取出按照某个字段进行排序后的记录结果集， 这就用到了数据库
的排序操作，用关键字 ORDER BY 来实现，语法如下：

SELECT * FROM tablename [WHERE CONDITION] [ORDER BY field1 [DESC|ASC]，field2
[DESC|ASC]，……fieldn [DESC|ASC]]

其中，DESC 和 ASC 是排序顺序关键字，DESC 表示按照字段进行降序排列，ASC 则表示升序
排列，如果不写此关键字默认是升序排列。ORDER BY 后面可以跟多个不同的排序字段，并
且每个排序字段可以有不同的排序顺序。


对于排序后的记录，如果希望只显示一部分，而不是全部，这时，就可以使用 LIMIT 关键字
来实现，LIMIT 的语法如下：

>SELECT ……[LIMIT offset_start,row_count]

其中 offset_start 表示记录的起始偏移量，row_count 表示显示的行数。

emp 表中按照 sal 排序后的前 3 条记录：

mysql> select * from emp order by sal limit 3;

如果要显示 emp 表中按照 sal 排序后从第二条记录开始，显示 3 条记录：

mysql> select * from emp order by sal limit 1,3;



（4）聚合。
很多情况下，我们需要进行一些汇总操作，比如统计整个公司的人数或者统计每个部门的人
数，这个时就要用到 SQL 的聚合操作。


聚合操作的语法如下：

```
SELECT [field1,field2,……fieldn] fun_name
FROM tablename
[WHERE where_contition]
[GROUP BY field1,field2,……fieldn
[WITH ROLLUP]]
[HAVING where_contition]

```
对其参数进行以下说明。

1 fun_name 表示要做的聚合操作，也就是聚合函数，常用的有 sum（求和）、count(*)（记
录数）、max（最大值）、min（最小值）。

2 GROUP BY 关键字表示要进行分类聚合的字段，比如要按照部门分类统计员工数量，部门
就应该写在 group by 后面。

3 WITH ROLLUP 是可选语法，表明是否对分类聚合后的结果进行再汇总。

4 HAVING 关键字表示对分类后的结果再进行条件的过滤


```
注意：having 和 where 的区别在于 having 是对聚合后的结果进行条件的过滤，而 where 是在聚
合前就对记录进行过滤，如果逻辑允许，我们尽可能用 where 先过滤记录，这样因为结果
集减小，将对聚合的效率大大提高，最后再根据逻辑看是否用 having 进行再过滤。
```

```
例如，要 emp 表中统计公司的总人数：
mysql> select count(1) from emp;
+----------+
| count(1) |
+----------+
| 4 |
+----------+
1 row in set (0.00 sec)
在此基础上，要统计各个部门的人数：
mysql> select deptno,count(1) from emp group by deptno;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
| 2 | 1 |
| 4 | 1 |
+--------+----------+
3 rows in set (0.00 sec)
更细一些，既要统计各部门人数，又要统计总人数：
mysql> select deptno,count(1) from emp group by deptno with rollup;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
| 2 | 1 |
| 4 | 1 |
| NULL | 4 |
+--------+----------+
4 rows in set (0.00 sec)
统计人数大于 1 人的部门：
mysql> select deptno,count(1) from emp group by deptno having count(1)>1;
+--------+----------+
| deptno | count(1) |
+--------+----------+
| 1 | 2 |
+--------+----------+
1 row in set (0.00 sec)
最后统计公司所有员工的薪水总额、最高和最低薪水：
mysql> select * from emp;
+--------+------------+---------+--------+
| ename | hiredate | sal | deptno |
+--------+------------+---------+--------+
| zzx | 2000-01-01 | 100.00 | 1 |
| lisa | 2003-02-01 | 400.00 | 2 |
| bjguan | 2004-04-02 | 100.00 | 1 |
| dony | 2005-02-05 | 2000.00 | 4 |
+--------+------------+---------+--------+
4 rows in set (0.00 sec)
mysql> select sum(sal),max(sal),min(sal) from emp;
+----------+----------+----------+
| sum(sal) | max(sal) | min(sal) |
+----------+----------+----------+
| 2600.00 | 2000.00 | 100.00 |
+----------+----------+----------+
1 row in set (0.00 sec
```

（5）表连接。

当需要同时显示多个表中的字段时，就可以用表连接来实现这样的功能。

从大类上分，表连接分为内连接和外连接，它们之间的最主要区别是內连接仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录。我们最常用的是内连接

> select ename,deptname from emp,dept where emp.deptno=dept.deptno;

外连接有分为左连接和右连接，具体定义如下。
? 左连接：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录
? 右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录

>select ename,deptname from emp left join dept on emp.deptno=dept.deptno;


（6）子查询。
某些情况下，当我们查询的时候，需要的条件是另外一个 select 语句的结果，这个时候，就
要用到子查询。用于子查询的关键字主要包括 in、not in、=、!=、exists、not exists 等。

> select * from emp where deptno in(select deptno from dept);

```
注意：子查询和表连接之间的转换主要应用在两个方面：
?  MySQL 4.1 以前的版本不支持子查询，需要用表连接来实现子查询的功能
?  表连接在很多情况下用于优化子查询
```

（7）记录联合。
我们经常会碰到这样的应用，将两个表的数据按照一定的查询条件查询出来后，将结果合并
到一起显示出来，这个时候，就需要用 union 和 union all 关键字来实现这样的功能，具体语
法如下：

SELECT * FROM t1
UNION|UNION ALL
SELECT * FROM t2
……
UNION|UNION ALL
SELECT * FROM tn;

UNION 和 UNION ALL 的主要区别是 UNION ALL 是把结果集直接合并在一起，而 **UNION 是将
UNION ALL 后的结果进行一次 DISTINCT，去除重复记录后的结果。**


*****

##### DCL 语句

DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用，一般的开发人员很少使用。下面
通过一个例子来简单说明一下。

创建一个数据库用户 z1，具有对 sakila 数据库中所有表的 SELECT/INSERT 权限：

>mysql> grant select,insert on sakila.* to 'z1'@'localhost' identified by '123';

在数据库sakila的所有记录给zi用户，密码是123


由于权限变更，需要将 z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作：

>revoke insert on sakila.* from 'z1'@'localhost';

 grant 和 revoke 分别授出和收回了用户 z1 的部分权限，达到了我们的目的。

#### 按照层次看帮助

如果不知道帮助能够提供些什么，可以用“？contents”命令来显示所有可供查询的的分类，
如下例所示：

mysql> ? contents

对于列出的分类，可以使用“? 类别名称”的方式针对用户感兴趣的内容做进一步的查看

#### 快速查阅帮助
在实际应用当中，如果需要快速查阅某项语法时，可以使用关键字进行快速查询。例如，想
知道 show 命令都能看些什么东西，可以用如下命令：
mysql> ? show

mysql> ? create table


***
***

# 第二章：MySQL 支持的数据类型

在整数类型中，按照取值范围和存储方式不同，分为 tinyint、smallint、mediumint、int、
bigint 这 5 个类型

```
分别修改 id1 和 id2 的字段类型，加入 zerofill 参数：

mysql> alter table t1 modify id1 int zerofill;
Query OK, 1 row affected (0.04 sec)
Records: 1 Duplicates: 0 Warnings: 0


mysql> alter table t1 modify id2 int(5) zerofill;
Query OK, 1 row affected (0.03 sec)
Records: 1 Duplicates: 0 Warnings: 0
mysql> select * from t1;
+------------+-------+
| id1 | id2 |
+------------+-------+
| 0000000001 | 00001 |
+------------+-------+
1 row in set (0.00 sec)
``` 


所有的整数类型都有一个可选属性 UNSIGNED（无符号），如果需要在字段里面保存非负数或者需要较大的上限值时，可以用此选项，它的取值范围是正常值的下限取 0，上限取原值的 2 倍，例如，tinyint 有符号范围是-128～+127，而无符号范围是 0～255。如果一个列指定为 zerofill，则 MySQL 自动为该列添加 UNSIGNED 属性。另外，整数类型还有一个属性：AUTO_INCREMENT。在需要产生唯一标识符或顺序值时，可利用此属性，这个属性只用于整数类型。AUTO_INCREMENT 值一般从 1 开始，每行增加 1。


浮点数和定点数都可以用类型名称后加“(M,D)”的方式来进行表示，“(M,D)”表示该
值一共显示 M 位数字（整数位+小数位），其中 D 位位于小数点后面，M 和 D 又称为精度和
标度。例如 定义为 float(7,4)的一个列可以显示为-999.9999

 decimal 在不指定精度时，默认的整数位为 10，默认的小数位为 0。


浮点数如果不写精度和标度，则会按照实际精度值显示，如
果有精度和标度，则会自动将四舍五入后的结果插入，系统不会报错；定点数如果不写精度
和标度，则按照默认值 decimal(10,0)来进行操作，并且如果数据超越了精度和标度值，系统
则会报错。


对于 BIT（位）类型，用于存放位字段值，BIT(M)可以用来存放多位二进制数，M 范围从 1～
64，如果不写则默认为 1 位。对于位字段，直接使用 SELECT 命令将不会看到结果，可以用
bin()（显示为二进制格式）或者 hex()（显示为十六进制格式）函数进行读取。
下面的例子中，对测试表 t2 中的 bit 类型字段 id 做 insert 和 select 操作，这里重点观察一下
select 的结果：

```

mysql> desc t2;
+-------+--------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+--------+------+-----+---------+-------+
| id | bit(1) | YES | | NULL | |
+-------+--------+------+-----+---------+-------+
1 row in set (0.00 sec)

mysql> insert into t2 values(1);
Query OK, 1 row affected (0.00 sec)
mysql> select * from t2;
+------+
| id |
+------+
| |
+------+
1 row in set (0.00 sec)

可以发现，直接 select * 结果为 NULL。改用 bin()和 hex()函数再试试：
mysql> select bin(id),hex(id) from t2;
+---------+---------+
| bin(id) | hex(id) |
+---------+---------+
| 1 | 1 |
+---------+---------+
1 row in set (0.00 sec)
结果可以正常显示为二进制数字和十六进制数字。
```

### 日期时间类型


|日期和时间类型| 字节 | 最小值|  最大值|
|----|----|----|----|
|DATE|  4 | 1000-01-01 | 9999-12-31
|DATETIME | 8 | 1000-01-01 00:00:00  |9999-12-31 23:59:59
|TIMESTAMP | 4 | 19700101080001 | 2038 年的某个时刻
|TIME  |3 | -838:59:59 | 838:59:59
|YEAR|  1 | 1901|  2155

*  如果要用来表示年月日，通常用 DATE 来表示。
*  如果要用来表示年月日时分秒，通常用 DATETIME 表示。
*  如果只用来表示时分秒，通常用 TIME 来表示。
*  如果需要经常插入或者更新日期为当前系统时间，则通常使用 TIMESTAMP 来表示。
TIMESTAMP 值返回后显示为“YYYY-MM-DD HH:MM:SS”格式的字符串，显示宽度固定
为 19 个字符。如果想要获得数字值，应在 TIMESTAMP 列添加+0。
*  如果只是表示年份，可以用 YEAR 来表示，它比 DATE 占用更少的空间。YEAR 有 2 位或
4 位格式的年。默认是 4 位格式。在 4 位格式中，允许的值是 1901～2155 和 0000。在
2 位格式中，允许的值是 70～69，表示从 1970～2069 年。MySQL 以 YYYY 格式显示 YEAR
值。

### timestamp 

创建测试表t，字段id1为TIMESTAMP类型：

```
mysql> create table t (id1 timestamp);
Query OK, 0 rows affected (0.03 sec)

mysql> desc t;
+-------+-----------+------+-----+-------------------+-------+
| Field | Type | Null | Key | Default | Extra |
+-------+-----------+------+-----+-------------------+-------+
| id2 | timestamp | YES | | CURRENT_TIMESTAMP | |
+-------+-----------+------+-----+-------------------+-------+
1 row in set (0.00 sec)
```


可以发现，系统给 tm 自动创建了默认值 CURRENT_TIMESTAMP（系统日期）。插入一个 NULL
值试试：

```
mysql> insert into t values(null);
Query OK, 1 row affected (0.00 sec)


mysql> select * from t;
+---------------------+
| t |
+---------------------+
| 2007-07-04 16:37:24 |
+---------------------+
```


MySQL只给表中的第一个TIMESTAMP字段设置
默认值为系统日期，如果有第二个TIMESTAMP类型，则默认值设置为0值，测试如下：

```
mysql> alter table t add id2 timestamp;
Query OK, 0 rows affected (0.03 sec)
Records: 0 Duplicates: 0 Warnings: 0


mysql> show create table t \G;
*************************** 1. row ***************************
Table: t
Create Table: CREATE TABLE `t` (
`id1` timestamp NOT NULL default CURRENT_TIMESTAMP,
`id2` timestamp NOT NULL default '0000-00-00 00:00:00'
) ENGINE=MyISAM DEFAULT CHARSET=gbk
1 row in set (0.00 sec))
```


查看当前时区：
> show variables like 'time_zone';

修改时区为东九区，再次查看表中日期：
> set time_zone='+9:00';


### CHAR 和 VARCHAR 类型

CHAR 和 VARCHAR 很类似，都用来保存 MySQL 中较短的字符串。二者的主要区别在于存储
方式的不同：CHAR 列的长度固定为创建表时声明的长度，长度可以为从 0～255 的任何值；
而 VARCHAR 列中的值为可变长字符串，长度可以指定为 0～255 （5.0.3以前）或者 65535 （5.0.3
以后）之间的值。在检索的时候，CHAR 列删除了尾部的空格，而 VARCHAR 则保留这些空格



```
（1）创建测试表 vc，并定义两个字段 v VARCHAR(4)和 c CHAR(4)：

mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.16 sec)

（2）v 和 c 列中同时插入字符串“ab ”：

mysql> INSERT INTO vc VALUES ('ab ', 'ab ');
Query OK, 1 row affected (0.05 sec)

（3）显示查询结果：
mysql> select length(v),length(c) from vc;
+-----------+-----------+
Linux公社 www.linuxidc.com
71
| length(v) | length(c) |
+-----------+-----------+
| 4 | 2 |
+-----------+-----------+
1 row in set (0.01 sec)

可以发现，c 字段的 length 只有 2。给两个字段分别追加一个“+”字符看得更清楚：
mysql> SELECT CONCAT(v, '+'), CONCAT(c, '+') FROM vc;
+----------------+----------------+
| CONCAT(v, '+') | CONCAT(c, '+') |
+----------------+----------------+
| ab + | ab+ |
+----------------+----------------+
1 row in set (0.00 sec)
显然，CHAR 列最后的空格在做操作时都已经被删除，而 VARCHAR 依然保留空格。
```


### 算术运算符

比较运算符

MySQL 支持的比较运算符

|运算符|作用|
|-----|-----|
|= | 等于|
|<>或!=  |不等于|
|<=>  |NULL 安全的等于(NULL-safe)|
|< | 小于|
|<= | 小于等于|
|> | 大于|
|>= | 大于等于|
|BETWEEN  |存在与指定范围|
|IN  |存在于指定集合|
|IS NULL | 为 NULL|
|IS NOT NULL | 不为 NULL|
|LIKE | 通配符匹配|
|REGEXP 或 RLIKE | 正则表达式匹配|

```
mysql> select 1 in (1,2,3) , 't' in ('t','a','b','l','e'),0 in (1,2);
+--------------+------------------------------+------------+
| 1 in (1,2,3) | 't' in ('t','a','b','l','e') | 0 in (1,2) |
+--------------+------------------------------+------------+
| 1 | 1 | 0 |
+--------------+-------------

mysql> select 'abcdef' regexp 'ab' ,'abcdefg' regexp 'k';
+----------------------+----------------------+
| 'abcdef' regexp 'ab' | 'abcdefg' regexp 'k' |
+----------------------+----------------------+
| 1 | 0 |
+----------------------+----------------------+
1 row in set (0.00 sec)	
```

### 逻辑运算符

MySQL 中的逻辑运算符

|运算符 | 作用|
|----|----|
|NOT 或！|  逻辑非|
|AND 或&&  |逻辑与|
|OR 或两个竖杠 |逻辑或|
|XOR | 逻辑异或|


```
“XOR”表示逻辑异或。当任意一个操作数为 NULL 时，返回值为 NULL。对于非 NULL 的
操作数，如果两个的逻辑真假值相异，则返回结果 1；否则返回 0。如下例所示：


mysql> select 1 xor 1 ,0 xor 0,1 xor 0,0 xor 1,null xor 1;
+---------+---------+---------+---------+------------+
| 1 xor 1 | 0 xor 0 | 1 xor 0 | 0 xor 1 | null xor 1 |
+---------+---------+---------+---------+------------+
| 0 | 0 | 1 | 1 | NULL |
+---------+---------+---------+---------+------------+
1 row in set (0.00 sec)
```


### 位运算

位运算符
位运算是将给定的操作数转化为二进制后，对各个操作数每一位都进行指定的逻辑运算，
得到的二进制结果转换为十进制数后就是位运算的结果。MySQL 5.0 支持 6 种位运算符，

 MySQL 支持的位运算符

|运算符 | 作用|
|---|---|
|& | 位与（位 AND）|
|竖杠 | 位或 （位 OR ）|
|^|  位异或（位 XOR）|
|~ | 位取反|
|>>| 位右移|
|<< |位左移|


### 函数

#### 常用函数

![常用函数](https://i.loli.net/2017/09/23/59c5d354bc41b.png)


#### 数值函数
![数值函数](https://i.loli.net/2017/09/23/59c5eed50bf61.png)

![日期函数](https://i.loli.net/2017/09/23/59c5ef8970d3d.png)

#### 流程函数

![流程函数](https://i.loli.net/2017/09/23/59c5f36810b53.png)


```
IF(value,t,f)函数：我们认为月薪在 2000 元以上的职员属于高薪，用“high”表示；而
2000 元以下的职员属于低薪，用“low”表示。


mysql> select if(salary>2000,'high','low') from salary;
+------------------------------+
| if(salary>2000,'high','low') |
+------------------------------+
| low |
| low |
| high |
| high |
| high |
+------------------------------+
5 rows in set (0.01 sec)
```

CASE WHEN [value1] THEN[result1]…ELSE[default]END 函 数 ：

 我 们 也 可 以 用 case
when…then 函数实现上面例子中高薪低薪的问题。
mysql
> select case when salary<=2000 then 'low' else 'high' end from salary;


![其他函数](https://i.loli.net/2017/09/23/59c5f4e1a11d9.png)

>select DATABASE();

>select USER();


数据库详情
> show table status;


 # 第三章 存储引擎

MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、
NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安
全表，其他存储引擎都是非事务安全表。


查看当前的默认存储引擎，
可以使用以下命令：

> mysql> show variables like 'table_type';

可以通过下面两种方法查询当前数据库支持的存储引擎，第一种方法为：

> mysql> SHOW ENGINES \G

或者采用第二种方法：

> mysql> SHOW VARIABLES LIKE 'have%';


在创建新表的时候，可以通过增加 ENGINE 关键字设置新建表的存储引擎，例如，在下
面的例子中，表 ai 就是 MyISAM 存储引擎的，而 country 表就是 InnoDB 存储引擎的：

```
CREATE TABLE ai (
i bigint(20) NOT NULL AUTO_INCREMENT,
PRIMARY KEY (i)
) ENGINE=MyISAM DEFAULT CHARSET=gbk;

CREATE TABLE country (
country_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
country VARCHAR(50) NOT NULL,
last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (country_id)
)ENGINE=InnoDB DEFAULT CHARSET=gbk;
```


如何将表 ai 从 MyISAM 存储引擎修改成 InnoDB 存储引擎：
> alter table ai engine = innodb;


#### 各种存储引擎的特性:

![存储引擎](https://i.loli.net/2017/09/23/59c5fad5a550f.png)
'''
## MySQL数据库的Innodb和MyIASM两种引擎

####Innodb引擎

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，
该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，

当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率

####MyIASM引擎

MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描





|对比|优点|缺点|
|---|---|---|
|Innordb|1。事务的支持  2。提供了行级锁和外键约束 3。            ||
|MyIsam|存储了表的行数，select*效率高||



***
添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除）

达到锁表的效果

     try:
        with transaction.atomic():
            cursor = connection.cursor()
            cursor.execute("SELECT * FROM globallock FOR UPDATE")
            row = cursor.fetchone()

            # condition = 1  # 后期管理员控制 发车后是否可以取消预约 的字段
            reserveInforId = req.POST["reserveInforId"]
            time = datetime.datetime.strptime(req.POST["date"], '%Y-%m-%d')
            bus = req.POST["bus"]
            seat = req.POST["seat"]
            now = datetime.datetime.now()



'''


***
### MyISAM

MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访
问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用
这个引擎来创建表。
***
### InnoDB 


#### 外键约束

InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM
的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的
索引，子表在创建外键的时候也会自动创建对应的索引。

对于 InnoDB 类型的表，外键的信息通过使用 show create table 或者 show table status 命
令都可以显示。


## MEMORY
MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个
磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，
并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。

```
mysql> CREATE TABLE tab_memory ENGINE=MEMORY
-> SELECT city_id,city,country_id
-> FROM city GROUP BY city_id;
Query OK, 600 rows affected (0.06 sec)
Records: 600 Duplicates: 0 Warnings: 0
mysql> select count(*) from tab_memory;
+----------+
| count(*) |
+----------+
| 600 |
+----------+
1 row in set (0.00 sec)

mysql> show table status like 'tab_memory' \G

*************************** 1. row ***************************
Name: tab_memory
Engine: MEMORY
Version: 10
Row_format: Fixed
Rows: 600
Avg_row_length: 155
Data_length: 127040
Max_data_length: 16252835
Index_length: 0
Data_free: 0
Auto_increment: NULL
Create_time: NULL
Update_time: NULL
Check_time: NULL
Collation: gbk_chinese_ci
Checksum: NULL
Create_options:

Comment:
1 row in set (0.00 sec)
```

给 MEMORY 表创建索引的时候，可以指定使用 HASH 索引还是 BTREE 索引：

```
mysql> create index mem_hash USING HASH on tab_memory (city_id) ;
Query OK, 600 rows affected (0.04 sec)
Records: 600 Duplicates: 0 Warnings: 0

mysql> SHOW INDEX FROM tab_memory \G
*************************** 1. row ***************************
Table: tab_memory
Non_unique: 1
Key_name: mem_hash
Seq_in_index: 1
Column_name: city_id
Collation: NULL
Cardinality: 300
Sub_part: NULL
Packed: NULL
Null:
Index_type: HASH
Comment:
1 row in set (0.01 sec)
mysql> drop index mem_hash on tab_memory;
Query OK, 600 rows affected (0.04 sec)
Records: 600 Duplicates: 0 Warnings: 0
mysql> create index mem_hash USING BTREE on tab_memory (city_id) ;
Query OK, 600 rows affected (0.03 sec)
Records: 600 Duplicates: 0 Warnings: 0

mysql> SHOW INDEX FROM tab_memory \G
*************************** 1. row ***************************
Table: tab_memory
Non_unique: 1
Key_name: mem_hash
Seq_in_index: 1
Column_name: city_id
Collation: A
Cardinality: NULL
Sub_part: NULL
Packed: NULL
Null:
Index_type: BTREE
Comment:
1 row in set (0.00 sec)
```

在启动 MySQL 服务的时候使用--init-file 选项，把 INSERT INTO ... SELECT 或 LOAD DATA
INFILE 这样的语句放入这个文件中，就可以在服务启动时从持久稳固的数据源装载表

## 选择


*  MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以  **读操作和插入操作**为主，

只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存
储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎
之一。

*  InnoDB：用于    **事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，** 那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低
由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），
对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选
择。

* MEMORY：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境
下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内
存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。
*MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果。*

* MERGE：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象
引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同
的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。这对于诸如数据仓储等VLDB
环境十分适合



*****

### 数据类型 的选取



#### TEXT 与 BLOB
对表进行 OPTIMIZE（优化）操作：

> OPTIMIZE TABLE t;

可以使用 **合成的（Synthetic）索引**来提高大文本字段（BLOB 或 TEXT）的查询性能。
简单来说，合成索引就是根据大文本字段的内容建立一个散列值，并把这个值存储在单独的
数据列中，接下来就可以通过检索散列值找到数据行了

（精确匹配）

1）创建测试表 t，字段 id、context、hash_value 字段类型分别为 varchar(100)、blob、
varchar(40)：

mysql> create table t (id varchar(100),context blob,hash_value varchar(40));

2）t 中插入测试数据，其中 hash_value 用来存放 context 列的 MD5 散列值：

mysql> insert into t values(1,repeat('beijing',2),md5(context));

3）如果要查询 context 值为“beijing 2008beijing 2008”的记录，可以通过相应的散列值来
查询：

mysql> select * from t where hash_value=md5(repeat('beijing 2008',2));

### 浮点数与定点数
浮点数一般用于表示含有小数部分的数值。当一个字段被定义为浮点类型后，如果插入
数据的精度超过该列定义的实际精度， **则插入值会被四舍五入到实际定义的精度值**，然后插
入，四舍五入的过程不会报错。在 MySQL 中 float、double（或 real）用来表示浮点数。

定点数不同于浮点数，定点数实际上是以字符串形式存放的，所以  **定点数可以更加精确
的保存数据。如果实际插入的数值精度大于实际定义的精度，则 MySQL 会进行警告（默认
的 SQLMode 下），但是数据按照实际精度四舍五入后插入；**如果 SQLMode 是在 TRADITIONAL
（传统模式）下，则系统会直接报错，导致数据无法插入。在 MySQL 中，decimal （或 numberic）
用来表示定点数。

*****

# 第四章：MySQL 支持的字符集简介

MySQL 服务器可以支持多种字符集，在同一台服务器、同一个数据库、甚至同一个表
的不同字段都可以指定使用不同的字符集，相比 Oracle 等其他数据库管理系统，在同一个
数据库只能使用相同的字符集，MySQL 明显存在更大的灵活性

查看所有可用的字符集的命令是 
>show character set;

 information_schema.character_set，可以显示所有的字符集和该字符集默认的校对规则。
> desc information_schema.character_sets;

### 索 引 的 设 计 和 使用

MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引

支持前缀索引，即对索引字段的前 N 个字符创建索引


索引在创建表的时候可以同时创建，也可以随时增加新的索引。创建新索引的语法为：

```
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
[USING index_type]
ON tbl_name (index_col_name,...)
index_col_name:
col_name [(length)] [ASC | DESC]
```


也可以使用 ALTER TABLE 的语法来增加索引，语法可 CREATE INDEX 类似，可以查询帮助
获得详细的语法，这里不再复述。
例如，要为 city 表创建了 10 个字节的前缀索引，语法是：

```
mysql> create index cityname on city (city(10));
Query OK, 600 rows affected (0.26 sec)
Records: 600 Duplicates: 0 Warnings: 0
```

如果以 city 为条件进行查询，可以发现索引 cityname 被使用：

```
mysql> explain select * from city where city = 'Fuzhou' \G
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: city
type: ref
possible_keys: cityname
key: cityname
key_len: 32
ref: const
rows: 1
Extra: Using where
```


索引的删除语法为：

```
DROP INDEX index_name ON tbl_name

例如，想要删除 city 表上的索引 cityname，可以操作如下：

mysql> drop index cityname on city;
Query OK, 600 rows affected (0.23 sec)
Records: 600 Duplicates: 0 Warnings: 0
```

### 设计索引的原则

*最适合索引的列是出现在 WHERE
子句中的列，或连接子句中指定的列

*使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例
如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M”
和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。

*使用短索引。如果有一个 CHAR(200)列，如果在前 10 个或 20 个字符内，多数值是惟一
的， 那么就不要对整个列进行索引。 对前10个或20个字符进行索引能够节省大量索引空间，
也可能会使查询更快

# 第五章 视图

视图（View）是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并
不在数据库中实际存在， 行和列数据来自定义视图的查询中使用的表， 并且是在使用视图时
动态生成的。

创建视图需要有 CREATE VIEW 的权限，并且对于查询涉及的列有 SELECT 权限。如果使用
CREATE OR REPLACE 或者 ALTER 修改视图，那么还需要该视图的 DROP 权限。

创建视图的语法为：

```
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION]
```
```
修改视图的语法为：

ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW view_name [(column_list)]
AS select_statement
[WITH [CASCADED | LOCAL] CHECK OPTION]
```
```

例如,要创建了视图 staff_list_view,可以使用以下命令：

mysql> CREATE OR REPLACE VIEW staff_list_view AS
-> SELECT s.staff_id,s.first_name,s.last_name,a.address
-> FROM staff AS s,address AS a
-> where s.address_id = a.address_id ;
Query OK, 0 rows affected (0.00 sec)
```

# 第六章 存储过程和函数

####什么是存储过程和函数？
存储过程和函数是 **事先经过编译并存储在数据库中的一段 SQL 语句的集合**，调用存储过程
和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对
于提高数据处理的效率是有好处的。

存储过程和函数的区别在于函数必须有返回值，而存储过程没有，存储过程的参数可以使用
IN、OUT、INOUT 类型，而函数的参数只能是 IN 类型的。


新的过程 film_in_stock：

```
mysql> DELIMITER $$
mysql>
mysql> CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count
INT)
-> READS SQL DATA
-> BEGIN
-> SELECT inventory_id
-> FROM inventory
-> WHERE film_id = p_film_id
-> AND store_id = p_store_id
-> AND inventory_in_stock(inventory_id);
->
-> SELECT FOUND_ROWS() INTO p_film_count;
-> END $$
Query OK, 0 rows affected (0.00 sec)
mysql>
mysql> DELIMITER ;
```
上面是在使用的样例数据库中创建的一个过程，该过程用来检查 film_id 和 store_id 对应的
inventory 是否满足要求，并且返回满足要求的 inventory_id 以及满足要求的记录数。
通常我们在执行创建过程和函数之前，都会通过“DELIMITER $$”命令将语句的结束符从“;”
修改成其他符号，这里使用的是“$$”，这样在过程和函数中的“;”就不会被 MySQL 解释
成语句的结束而提示错误。在存储过程或者函数创建完毕，通过“DELIMITER ;”命令再将结
束符改回成“;”。

可以看到在这个过程中调用了函数 inventory_in_stock()，并且这个过程有两个输入参数和一
个输出参数。下面可以通过调用这个过程来看看返回的结果。

这个查询封装在存储过
程中调用，那么调用过程的执行情况如下：

```
mysql> CALL film_in_stock(2,2,@a);
+--------------+
| inventory_id |
+--------------+
| 10 |
| 11 |
+--------------+
2 rows in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
mysql> select @a;
+------+
| @a |
+------+
| 2 |
+------+
1 row in set (0.00 sec)
```

可以看到调用存储过程与直接执行 SQL 的效果是相同的，但是存储过程的好处在于 **处理逻
辑都封装在数据库端，调用者不需要了解中间的处理逻辑**，一旦处理逻辑发生变化，只需要
修改存储过程即可，而对调用者的程序完全没有影响。

### 查看存储过程或者函数
存储过程或者函数创建后，用户可能需要查看存储过程或者函数的状态或者定义等信息，便
于了解存储过程或者函数的基本情况。下面将介绍如何查看存储过程或函数相关信息。
#####查看存储过程或者函数的状态

>SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']

下面演示的是查看过程 film_in_stock 的信息：
```
mysql> show procedure status like 'film_in_stock'\G
*************************** 1. row ***************************
Db: sakila
Name: film_in_stock
Type: PROCEDURE
Definer: root@localhost
Modified: 2007-07-06 09:29:00
Linux公社 www.linuxidc.com
154
Created: 2007-07-06 09:29:00
Security_type: DEFINER
Comment:
1 row in set (0.00 sec)
```
##### 查看存储过程或者函数的定义

>SHOW CREATE {PROCEDURE | FUNCTION} sp_name

下面演示的是查看过程 film_in_stock 的定义：

```
mysql> show create procedure film_in_stock \G
*************************** 1. row ***************************
Procedure: film_in_stock
sql_mode:
Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `film_in_stock`(IN p_film_id
INT, IN p_store_id INT, OUT p_film_count INT)
READS SQL DATA
BEGIN
SELECT inventory_id
FROM inventory
WHERE film_id = p_film_id
AND store_id = p_store_id
AND inventory_in_stock(inventory_id);
SELECT FOUND_ROWS() INTO p_film_count;
END
1 row in set (0.00 sec)
```

####变量
#####变量的定义
通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中，可以用
在嵌套的块中。变量的定义必须写在复合语句的开头，并且在任何其他语句的前面。可以一
次声明多个相同类型的变量。如果需要，可以使用 DEFAULT 赋默认值。
定义一个变量的语法如下：

>DECLARE var_name[,...] type [DEFAULT value]

例如，定义一个 DATE 类型的变量，名称是 last_month_start：

>DECLARE last_month_start DATE;

#####变量的赋值
变量可以直接赋值，或者通过查询赋值。
直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：
>SET var_name = expr [, var_name = expr] ...

给刚才定义的变量 last_month_start 赋值，具体语法如下：

>SET last_month_start = DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH);

#### 光标的使用

在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、
OPEN、FETCH 和 CLOSE，其语法分别如下。

* 声明光标：
DECLARE cursor_name CURSOR FOR select_statement

* OPEN 光标：
OPEN cursor_name

* FETCH 光标：
FETCH cursor_name INTO var_name [, var_name] ...

* CLOSE 光标：
CLOSE cursor_name

以下例子是一个简单的使用光标的过程，对 payment 表按照行进行循环的处理，按照 staff_id
值的不同累加 amount 的值，判断循环结束的条件是捕获 NOT FOUND 的条件，当 FETCH 光
标找不到下一条记录的时候，就会关闭光标然后退出过程。

```
mysql> delimiter $$
mysql>
mysql> CREATE PROCEDURE payment_stat ()
-> BEGIN
-> DECLARE i_staff_id int;
-> DECLARE d_amount decimal(5,2);
-> DECLARE cur_payment cursor for select staff_id,amount from payment;
-> DECLARE EXIT HANDLER FOR NOT FOUND CLOSE cur_payment;
->
-> set @x1 = 0;
-> set @x2 = 0;
->
-> OPEN cur_payment;
->
-> REPEAT
-> FETCH cur_payment INTO i_staff_id, d_amount;
-> if i_staff_id = 2 then
-> set @x1 = @x1 + d_amount;
-> else
-> set @x2 = @x2 + d_amount;
-> end if;
-> UNTIL 0 END REPEAT;
->
-> CLOSE cur_payment;
->
-> END;
-> $$
Query OK, 0 rows affected (0.00 sec)
mysql> delimiter ;

mysql>
mysql> call payment_stat();
Query OK, 0 rows affected (0.11 sec)
mysql> select @x1,@x2;
+----------+----------+
| @x1 | @x2 |
+----------+----------+
| 33927.04 | 33489.47 |
+----------+----------+
1 row in set (0.00 sec)
```

# 第七章  触发器

####创建触发器
创建触发器的语法如下：

>CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt

对同一个表相同触发时间的相同触发事件，只能定义一个触发器。 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。
现在触发器还只支持行级触发的，不支持语句级触发。

为 film 表创建了 AFTER INSERT 的触发器，具体如下：

```
DELIMITER $$
CREATE TRIGGER ins_film
AFTER INSERT ON film FOR EACH ROW BEGIN
INSERT INTO film_text (film_id, title, description)
VALUES (new.film_id, new.title, new.description);
END;
$$
delimiter ;
```

对于有重复记录，需要进行 UPDATE 操作的 INSERT，触发器触发的
顺序是 BEFORE INSERT、BEFORE UPDATE、AFTER UPDATE；

对于没有重复记录的 INSERT，就是简单的执行 INSERT 操作，触发器触发的顺序是 BEFORE INSERT、AFTER INSERT。

对于那些实际执行 UPDATE 操作的记录，仍然会执行 BEFORE INSERT 触发器的内容，

在设计触发器的
时候一定要考虑这种情况，避免错误地触发了触发器。

####删除触发器
一次可以删除一个触发程序，如果没有指定 schema_name，默认为当前数据库,具体语法如
下：

>DROP TRIGGER [schema_name.]trigger_name

例如，要删除 film 表上的触发器 ins_film，可以使用以下命令：

```
mysql> drop trigger ins_film;
Query OK, 0 rows affected (0.00 sec)
```

#### 查看触发器
可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息，但是因为不能查询指
定的触发器，所以每次都返回所有的触发器的信息，使用起来不是很方便，具体语法如下：
>mysql> show triggers \G

查询系统表的 information_schema.triggers 表，这个方式可以查询指定
触发器的指定信息，操作起来明显方便很多：

>mysql> desc triggers;

> select * from triggers where trigger_name = 'ins_film_bef' \G

# 第八章   事务控制和锁定语

#### MySQL 支持

对 MyISAM 和 MEMORY 存储引擎的表进行表级锁定，

对 BDB 存储引擎的表进行页级锁定，

对 InnoDB 存储引擎的表进行行级锁定


#### 事务控制
MySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支
持本地事务，

默认情况下，MySQL 是自动提交（Autocommit）的，如果需要通过明确的 Commit 和
Rollback 来提交和回滚事务，那么需要通过明确的事务控制命令来开始事务，这是和 Oracle
的事务管理明显不同的地方。如果应用是从 Oracle 数据库迁移到 MySQL 数据库，则需要确
保应用中是否对事务进行了明确的管理。

* START TRANSACTION 或 BEGIN 语句可以开始一项新的事务。

* COMMIT 和 ROLLBACK 用来提交或者回滚事务。

* CHAIN 和 RELEASE 子句分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立
即启动一个新事物，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的
连接。

* SET AUTOCOMMIT 可以修改当前连接的提交方式，如果设置了 SET AUTOCOMMIT=0，
则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。

使用 START TRANSACTION 开始的事务在提交后自动回到自
动提交的方式；如果在提交的时候使用 COMMIT AND CHAIN，那么会在提交后立即开始一个
新的事务。

如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock
tables 被执行，

#### SAVEPOINT
在事务中可以通过定义 SAVEPOINT，指定回滚事务的一个部分，但是不能指定提交事务
的一个部分。对于复杂的应用，可以定义多个不同的 SAVEPOINT，满足不同的条件时，回滚
不同的 SAVEPOINT。需要注意的是，如果定义了相同名字的 SAVEPOINT，则后面定义的
SAVEPOINT 会覆盖之前的定义。对于不再需要使用的 SAVEPOINT，可以通过 RELEASE
SAVEPOINT 命令删除 SAVEPOINT，删除后的 SAVEPOINT，不能再执行 ROLLBACK TO SAVEPOINT
命令。

# 第九章 SQL Mode的相关问题

* 通过设置 SQL Mode，可以完成不同严格程度的数据校验，有效地保障数据准确性。

*  通过设置 SQL Mode 为 ANSI 模式，来保证大多数 SQL 符合标准的 SQL 语法,这样应用在
不同数据库之间进行迁移时，则不需要对业务 SQL 进行较大的修改。

*  在不同数据库之间进行数据迁移之前，通过设置 SQL Mode 可以使 MySQL 上的数据更方
便地迁移到目标数据库中。

一个简单的实例，让大家了解如何使用 SQL Mode 实现数据校验。

在 MySQL 5.0 上，查询默认的 SQL Mode（sql_mode 参数）为：REAL_AS_FLOAT、
PIPES_AS_CONCAT、ANSI_QUOTES、GNORE_SPACE 和 ANSI。在这种模式下允许插入超过字段
长度的值，只是在插入后，MySQL 会返回一个 warning。通过修改 sql_mode 为
STRICT_TRANS_TABLES（严格模式）实现了数据的严格校验，使错误数据不能插入表中，从
而保证了数据的准确性。

查看默认 SQL Mode 的命令如下：

>mysql> select @@sql_mode;

##### SQL Mode 的常见功能 

* 效验日期数据合法性，这是 SQL Mode 的一项常见功能。
在下面的例子中，观察一下非法日期“2007-04-31” （因为 4 月份没有 31 日）在不同 SQL Mode
下能否正确插入。

```
mysql> set session sql_mode='ANSI';
Query OK, 0 rows affected (0.00 sec)
mysql> create table t (d datetime);
Query OK, 0 rows affected (0.03 sec)
mysql> insert into t values('2007-04-31');
Query OK, 1 row affected, 1 warning (0.00 sec)
mysql> select * from t;
+---------------------+
| d |
+---------------------+
| 0000-00-00 00:00:00 |
+---------------------+
1 row in set (0.00 sec)
mysql> set session sql_mode='TRADITIONAL';
Query OK, 0 rows affected (0.00 sec)
mysql> insert into t values('2007-04-31');
ERROR 1292 (22007): Incorrect datetime value: '2007-04-31' for column 'd' at row 1
```
很显然，在 ANSI 模式下，非法日期可以插入，但是插入值却变为“0000-00-00 00:00:00”，
并且系统给出了 warning；而在 TRADITIONAL 模式下，在直接提示日期非法，拒绝插入。

* 在INSERT或UPDATE过程中，如果SQL MODE处于TRADITIONAL模式，运行MOD(X，
0)会产生错误，因为 TRADITIONAL 也属于严格模式，在非严格模式下 MOD(X，0)返回的结
果是 NULL，所以在含有 MOD 的运算中要根据实际情况设定好 sql_mode。
下面的实例展示了不同 sql_mode 下，MOD(X，0)返回的结果。

```
mysql> set sql_mode='ANSI' ;
Query OK, 0 rows affected (0.00 sec)
mysql> create table t (i int);
Query OK, 0 rows affected (0.02 sec)
mysql> insert into t values(9%0);
Query OK, 1 row affected (0.00 sec)
mysql> select * from t;

+------+
| i |
+------+
| NULL |
+------+
1 row in set (0.00 sec)
mysql> set session sql_mode='TRADITIONAL';
Query OK, 0 rows affected (0.00 sec)
mysql> insert into t values(9%0);
ERROR 1365 (22012): Division by 0
```
 * 启用 NO_BACKSLASH_ESCAPES 模式，使反斜线成为普通字符。在导入数据时，如
果数据中含有反斜线字符，启用 NO_BACKSLASH_ESCAPES 模式保证数据的正确性，是个不错
的选择。
以下实例说明了启用 NO_BACKSLASH_ESCAPES 模式前后对反斜线“\”插入的变化。

```
mysql> set sql_mode='ansi';
Query OK, 0 rows affected (0.00 sec)
mysql> select @@sql_mode;
+-------------------------------------------------------------+
| @@sql_mode |
+-------------------------------------------------------------+
| REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI |
+-------------------------------------------------------------+
1 row in set (0.00 sec)
mysql> create table t (context varchar(20));
Query OK, 0 rows affected (0.04 sec)
mysql> insert into t values('\beijing');
Query OK, 1 row affected (0.00 sec)
mysql> select * from t;
+---------+
| context |
+---------+
|eijing |
+---------+
1 row in set (0.00 sec)
mysql> insert into t values('\\beijing');
Query OK, 1 row affected (0.00 sec)

mysql> select * from t;
+----------+
| context |
+----------+
|eijing |
| \beijing |
+----------+
2 rows in set (0.00 sec)
mysql>set
sql_mode='REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI,NO_BACKSLASH_ESCAPES';
Query OK, 0 rows affected (0.00 sec)
mysql> select @@sql_mode;
+----------------------------------------------------------------------------------+
| @@sql_mode |
+----------------------------------------------------------------------------------+
| REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI,NO_BACKSLASH_ESCAPES |
+----------------------------------------------------------------------------------+
1 row in set (0.00 sec)
mysql> insert into t values('\\beijing');
Query OK, 1 row affected (0.00 sec)
mysql> select * from t;
+-----------+
| context |
+-----------+
|eijing |
| \beijing |
| \\beijing |
+-----------+
3 rows in set (0.00 sec)
```
通过上面的实例可以看到，当在 ANSI 模式中增加了 NO_BACKSLASH_ESCAPES 模式后，反斜
线变为了普通字符。如果导入的数据存在反斜线，可以设置此模式，保证导入数据的正确性。

* 启用 PIPES_AS_CONCAT 模式。将“||”视为字符串连接操作符，在 Oracle 等数据
库中，“||”被视为字符串的连接操作符，所以，在其他数据库中含有“||”操作符的 SQL
在 MySQL 中将无法执行，为了解决这个问题，MySQL 提供了 PIPES_AS_CONCAT 模式。
下面通过实例介绍一下 PIPES_AS_CONCAT 模式的作用。

```
mysql> set sql_mode='ansi';
Query OK, 0 rows affected (0.00 sec)
mysql> select @@sql_mode;
+-------------------------------------------------------------+

| @@sql_mode |
+-------------------------------------------------------------+
| REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ANSI |
+-------------------------------------------------------------+
1 row in set (0.00 sec)
mysql> select 'beijing'||'2008' ;
+-------------------+
| 'beijing'||'2008' |
+-------------------+
| beijing2008 |
+-------------------+
1 row in set (0.01 sec)
```
通过上面的实例可以看到，ANSI 模式中包含了 PIPES_AS_CONCAT 模式，所以默认情况下
MySQL 新版本支持将“||”视为字符串连接操作符。

*  SQL Mode 的“严格模式”为 MySQL 提供了很好的数据校验功能，保证了数据的准确性，
TRADITIONAL、STRICT_TRANS_TABLES 是常用的两种严格模式。
*  SQL Mode 的多种模式可以灵活组合，组合后的模式可以更好地满足应用程序的需求。
尤其在数据迁移中，SQL Mode 的使用更为重要。

# 第十章 简单SQL技巧

#### 正则表达式的使用

\^  在字符串的开始处进行匹配，返回结果为 1 表示匹配，返回结果为 0 表示不匹配。

下例中尝试匹配字符串“abcdefg”是否以字符“a”开始：

```
mysql> select 'abcdefg' REGEXP '^a';
+-----------------------+
| 'abcdefg' REGEXP '^a' |
+-----------------------+
| 1 |
+-----------------------+
1 row in set (0.39 sec)
```
使用正则表达式查询出使用 163.com 邮箱的用户和邮箱。

>mysql> select name ,email from t where email REGEXP "@163[.,]com$";

#### 巧用 RAND()提取随机行

可以利用这个函数与ORDER BY子句一起完成随机抽取某些行的功能。它的原理其实
就是ORDER BY RAND()能够把数据随机排序。

>mysql> select * from sales2 order by rand() limit 5;

#### 数据库名、表名大小写问题


# SQL优化

#### 通过 show status 命令了解各种 SQL 的执行频率

MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信
息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show
[session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当
前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使
用参数是“session”。

下面的命令显示了当前 session 中所有统计参数的值：

```
mysql> show status like 'Com_%';
+--------------------------+-------+
| Variable_name | Value |
+--------------------------+-------+
| Com_admin_commands | 0 |
| Com_alter_db | 0 |
| Com_alter_event | 0 |
| Com_alter_table | 0 |
| Com_analyze | 0 |
| Com_backup_table | 0 |
| Com_begin | 0 |
| Com_change_db | 1 |
| Com_change_master | 0 |
| Com_check | 0 |
| Com_checksum | 0 |
| Com_commit | 0 |
……
```

Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

*  Com_select：执行 select 操作的次数，一次查询只累加 1。
*  Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。
*  Com_update：执行 UPDATE 操作的次数。
*  Com_delete：执行 DELETE 操作的次数。

上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对
InnoDB 存储引擎的，累加的算法也略有不同。

*  Innodb_rows_read：select 查询返回的行数。
*  Innodb_rows_inserted：执行 INSERT 操作插入的行数。
*  Innodb_rows_updated：执行 UPDATE 操作更新的行数。
*  Innodb_rows_deleted：执行 DELETE 操作删除的行数。

通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询
操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行
次数的计数，不论提交还是回滚都会进行累加。


对于事务型的应用，通过 Com_commit 和 Com_rollback可以了解事务提交和回滚的情况，
对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。
此外，以下几个参数便于用户了解数据库的基本情况。

*  Connections：试图连接 MySQL 服务器的次数。
*  Uptime：服务器工作时间。
*  Slow_queries：慢查询的次数。


#### 定位执行效率较低的 SQL 语句

可以通过以下两种方式定位执行效率较低的 SQL 语句。

*  通过慢查询日志定位那些执行效率较低的 SQL 语句，用--log-slow-queries[=file_name]选
项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志
文件。具体可以查看本书第 26 章中日志管理的相关部分。

*  慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查
询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，
包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操
作进行优化。

#### 通过 EXPLAIN 分析低效 SQL 的执行计划

通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL
如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比
如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段
做求和（sum）操作，相应 SQL 的执行计划如下：

```
mysql> explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year
= 2006\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: a
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 1000
Extra: Using where
*************************** 2. row ***************************
id: 1
select_type: SIMPLE
table: b
type: ref
possible_keys: ind_company_id
key: ind_company_id
key_len: 5
ref: sakila.a.company_id
rows: 1
Extra: Using where; Using index
2 rows in set (0.00 sec)
```

每个列的简单解释如下：

*  select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接
或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或
者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。
*  table：输出结果集的表。
*  type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即
常量表）、

const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、

eq_ref（对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接
中使用primary key或者unique index）、

ref （与eq_ref类似，区别在于不是使用primary
key 或者 unique index，而是使用普通的索引）、

ref_or_null（与 ref 类似，区别在于
条件中包含对 NULL 的查询）、

index_merge(索引合并优化)、

unique_subquery（in
的后面是一个查询主键字段的子查询）、

index_subquery （与 unique_subquery 类似，
区别在于 in 的后面是查询非唯一索引字段的子查询）、

range（单表中的范围查询）、
index（对于前面的每一行，都通过查询索引来得到数据）、

all （对于前面的每一行，
都通过全表扫描来得到数据）。

*  possible_keys：表示查询时，可能使用的索引。
*  key：表示实际使用的索引。
*  key_len：索引字段的长度。
*  rows：扫描行的数量。
*  Extra：执行情况的说明和描述。

####  确定问题并采取相应的优化措施
经过以上步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措
施，进行优化提高执行的效率。
在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的
year 字段创建索引，具体如下：

```
mysql> create index ind_sales2_year on sales2(year);
Query OK, 1000 rows affected (0.03 sec)
Records: 1000 Duplicates: 0 Warnings: 0
```

创建索引后，再看一下这条语句的执行计划，具体如下：

```
mysql> explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and a.year = 2006\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: a
type: ref
possible_keys: ind_sales2_year
key: ind_sales2_year
key_len: 2
ref: const
rows: 1
Extra: Using where
*************************** 2. row ***************************
id: 1
select_type: SIMPLE
table: b
type: ref
possible_keys: ind_company2_id
key: ind_company2_id
key_len: 5
ref: sakila.a.company_id
rows: 1
Extra: Using where; Using index
2 rows in set (0.00 sec)
```

可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的
使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。

#### 索引问题

索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数
的 SQL 性能问题。

MySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：

MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；

MEMORY/HEAP 存储引擎可以支持 HASH和 BTREE 索引。

MySQL 目前不支持函数索引，但是能对列的前面某一部分进索引，例如 name 字段，可
以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计
表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子：

```
mysql> create index ind_company2_name on company2(name(4));
Query OK, 1000 rows affected (0.03 sec)
Records: 1000 Duplicates: 0 Warnings: 0
```

#### 使用索引(索引被使用到的情况)

* 对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，

```
mysql> create index ind_sales2_companyid_moneys on sales2(company_id,moneys);

explain select * from sales2 where company_id = 2006\G;  #有效

explain select * from sales2 where moneys = 1\G;    # 无效
```

* 对于使用 like 的查询，后面如果是常量并且只有％号不在第一个字符，索引才可能会
被使用，来看下面两个执行计划

```
explain select * from company2 where name like '%3'\G;    #无效

explain select * from company2 where name like '3%'\G;    #有效
```
* 如果对大的文本进行搜索，使用全文索引而不用使用 like ‘%…%’。

* 如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null
的记录就用到了索引：
mysql> explain select * from company2 where name is null\G;

####查看索引使用情况

如果索引正在工作，Handler_read_key 的值将很高
，这个值代表了一个行被索引值读的
次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。

Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值
的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，


Handler_read_rnd_next 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具
体如下。

```
mysql> show status like 'Handler_read%';
+-----------------------+-------+
| Variable_name | Value |
+-----------------------+-------+
| Handler_read_first | 0 |
| Handler_read_key | 5 |
| Handler_read_next | 0 |
| Handler_read_prev | 0 |
| Handler_read_rnd | 0 |
| Handler_read_rnd_next | 2055 |
+-----------------------+-------+
6 rows in set (0.00 sec)
```
从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。

#### 两个简单实用的优化方法

* 定期分析表和检查表

对表 sales 做了表分析：

```
mysql> analyze table sales;
+--------------+---------+----------+----------+
| Table | Op | Msg_type | Msg_text |
+--------------+---------+----------+----------+
Linux公社 www.linuxidc.com
214
| sakila.sales | analyze | status | OK |
+--------------+---------+----------+----------+
1 row in set (0.00 sec)
```
检查表的语法如下：

>CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED
| CHANGED}

检查表的作用是检查一个或多个表是否有错误。CHECK TABLE对MyISAM和InnoDB表有作用。
对于 MyISAM 表，关键字统计数据被更新，例如：

```
mysql> check table sales;
+--------------+-------+----------+----------+
| Table | Op | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| sakila.sales | check | status | OK |
+--------------+-------+----------+----------+
1 row in set (0.00 sec)
```
CHECK TABLE 也可以检查视图是否有错误

* 定期优化表
优化表的语法如下：

OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...

如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表（含有 VARCHAR、
BLOB 或 TEXT 列的表）进行了很多更改，则应使用 OPTIMIZE TABLE 命令来进行表优化。这个
命令可以将 **表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费**，但
OPTIMIZE TABLE 命令只对 MyISAM、BDB 和 InnoDB 表起作用。
以下例子显示了优化表 sales 的过程：

```
mysql> optimize table sales;
+--------------+----------+----------+----------+
| Table | Op | Msg_type | Msg_text |
+--------------+----------+----------+----------+
| sakila.sales | optimize | status | OK |
+--------------+----------+----------+----------+
1 row in set (0.00 sec)
```
注意：ANALYZE、CHECK、OPTIMIZE 执行期间将对表进行锁定，因此一定注意要在数据库不
繁忙的时候执行相关的操作。



#### 常用 SQL 的优化

* 大批量插入数据

当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。
对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。

```
ALTER TABLE tbl_name DISABLE KEYS;
loading the data
ALTER TABLE tbl_name ENABLE KEYS;
```

# 锁问题

MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；

BDB
存储引擎采用的是页面锁（page-level locking），但也支持表级锁；

InnoDB存储引擎既支持行
级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

MySQL这3种锁的特性可大致归纳如下。

*  表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发
度最低。
*  行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发
度也最高。
*  页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁
之间，并发度一般。

#### MyISAM 表锁 

* 查询表级锁争用情况

可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁
定争夺：

```
mysql> show status like 'table%';
+-----------------------+-------+
| Variable_name | Value |
+-----------------------+-------+
| Table_locks_immediate | 2979 |
| Table_locks_waited | 0 |
+-----------------------+-------+
2 rows in set (0.00 sec))
```
如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。

* MySQL 表级锁的锁模式

对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的
写请求；对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作

> lock table film_text write;

> unlock tables;

* 如何加表锁

MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作
（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁

给 MyISAM 表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的
一致性读取

MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正
是 MyISAM 表不会出现死锁（Deadlock Free）的原因。

并发插入（Concurrent Inserts）

上文提到过 MyISAM 表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM
表也支持查询和插入操作的并发进行。

MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值
分别可以为0、1或2。

*  当concurrent_insert设置为0时，不允许并发插入。
*  当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的
行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL
的默认设置。
*  当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入
记录。


#### MyISAM 的锁调度

前面讲过，MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程
请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢？
答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插
到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表
不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作


很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过
一些设置来调节 MyISAM 的调度行为。

* 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
* 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
* 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

虽然上面 3 种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查
询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。

另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count
设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，
给读进程一定获得锁的机会。

上面已经讨论了写优先调度机制带来的问题和解决办法。这里还要强调一点：一些需要长时
间运行的查询操作，也会使写进程“饿死”！因此， **应用中应尽量避免出现长时间运行的查
询操作，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较
复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分
解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽
量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。**


#### InnoDB 锁问题

InnoDB 与 MyISAM 的最大不同有两点：一是支持事务（TRANSACTION） ；二是采用
了行级锁。

事务的ACID 属性。

*  原子性（Atomicity） ：事务是一个原子操作单元，其对数据的修改，要么全都执行，
要么全都不执行。
*  一致性（Consistent） ：在事务开始和完成时，数据都必须保持一致状态。这意味着
所有相关的数据规则都必须应用于事务的修改， 以保持数据的完整性； 事务结束时，
所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。
*  隔离性（Isolation） ：数据库系统提供一定的隔离机制，保证事务在不受外部并发操
作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见
的，反之亦然。
*  持久性（Durable） ：事务完成之后，它对于数据的修改是永久性的，即使出现系统
故障也能够保持。
















并发事务处理带来的问题

相对于串行处理来说， 并发事务处理能大大增加数据库资源的利用率， 提高数据库系统的事
务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几
种情况。

* 更新丢失（Lost Update） ：当两个或多个事务选择同一行，然后基于最初选定的
值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题
－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一
文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这
样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做
的更改。 如果在一个编辑人员完成并提交事务之前， 另一个编辑人员不能访问同
一文件，则可避免此问题。

* 脏读（Dirty Reads） ：一个事务正在对一条记录做修改，在这个事务完成并提交
前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，
如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就
会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。

* 不可重复读（Non-Repeatable Reads） ：一个事务在读取某些数据后的某个时间，
再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已
经被删除了！这种现象就叫做“不可重复读” 。

* 幻读 （Phantom Reads） ： 一个事务按相同的查询条件重新读取以前检索过的数据，
却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。
























事务隔离级别

数据库实现事务隔离的方式，基本上可分为以下两种。

* 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
* 另一种是不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快
照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。
从用户的角度来看，好象是数据库可以提供同一数据的多个版本，因此，这种技
术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或
MCC） ，也经常称为多版本数据库。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92 定义了 4 个事务隔离级别，每个级别
的隔离程度不同，允许出现的副作用也不同

获取 InnoDB 行锁争用情况 

可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：

````
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0 |
| InnoDB_row_lock_time | 0 |
| InnoDB_row_lock_time_avg | 0 |
| InnoDB_row_lock_time_max | 0 |
| InnoDB_row_lock_waits | 0 |
+-------------------------------+-------+
5 rows in set (0.01 sec)
```
如果发现锁争用比较严重， 如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值
比较高，还可以通过设置 InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分
析锁争用的原因。
具体方法如下：

```
mysql> CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;
Query OK, 0 rows affected (0.14 sec)
```
然后就可以用下面的语句来进行查看：

```
mysql> Show innodb status\G;
*************************** 1. row ***************************
Type: InnoDB
Name:
Status:
…
…
------------
TRANSACTIONS
------------
Trx id counter 0 117472192
Purge done for trx's n:o < 0 117472190 undo n:o < 0 0
History list length 17
Total number of lock structs in row lock hash table 0
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 0 117472185, not started, process no 11052, OS thread id 1158191456
MySQL thread id 200610, query id 291197 localhost root
---TRANSACTION 0 117472183, not started, process no 11052, OS thread id 1158723936
MySQL thread id 199285, query id 291199 localhost root
Show innodb status
…
```

监视器可以通过发出下列语句来停止查看：

```
mysql> DROP TABLE innodb_monitor;
Query OK, 0 rows affected (0.05 sec)
```

设置监视器后， 在 SHOW INNODB STATUS 的显示内容中， 会有详细的当前锁等待的信息，
包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器
以后，默认情况下每 15 秒会向日志中记录监控的内容，如果长时间打开会导致.err 文件变
得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过
使用“--console”选项来启动服务器以关闭写日志文件。

事务可以通过以下语句显示给记录集加共享锁或排他锁。

* 共享锁（S） ：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。


* 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。


用 SELECT ... IN SHARE MODE 获得共享锁，主要用在需要数据依存关系时来确认某行记
录是否存在，并确保没有人对这个记录进行 UPDATE 或者 DELETE 操作。但是如果当前事务
也需要对该记录进行更新操作， 则很有可能造成死锁， **对于锁定行记录后需要进行更新操作的应用，应该使用 SELECT... FOR UPDATE 方式获得排他锁。**

InnoDB 行锁实现方式

InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是
通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过
索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！

 session_1 只给一行加了排他锁，但 session_2 在请
求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB 只能使用
表锁。


关于死锁

例子中， 两个事务都需要获得对方持有的排他锁才能继续完成事务， 这种循环锁等
待就是典型的死锁。

几种避免死锁的常用方法。

* 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问
表，这样可以大大降低产生死锁的机会。在下面的例子中，由于两个 session 访问两个表的
顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可以避免。


对于 MyISAM 的表锁，主要讨论了以下几点：

1. 共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他
写锁（X）之间是互斥的，也就是说读和写是串行的。

2. 在一定条件下，MyISAM 允许查询和插入并发执行，我们可以利用这一点来解决
应用中对同一表查询和插入的锁争用问题。

3.MyISAM 默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过
设置 LOW_PRIORITY_UPDATES 参数，或在 INSERT、UPDATE、DELETE 语句中指定
LOW_PRIORITY 选项来调节读写锁的争用。

4. 由于表锁的锁定粒度大， 读写之间又是串行的， 因此， 如果更新操作较多， MyISAM
表可能会出现严重的锁等待，可以考虑采用 InnoDB 表来减少锁冲突。


对于 InnoDB 表，本章主要讨论了以下几项内容。
* InnoDB 的行锁是基于锁引实现的， 如果不通过索引访问数据， InnoDB 会使用表锁。

* 介绍了 InnoDB 间隙锁（Next-key)机制，以及 InnoDB 使用间隙锁的原因。

* 在不同的隔离级别下，InnoDB 的锁机制和一致性读策略不同。

*  MySQL 的恢复和复制对 InnoDB 锁机制和一致性读策略也有较大影响。

*  锁冲突甚至死锁很难完全避免。

在了解 InnoDB 锁特性后，用户可以通过设计和 SQL 调整等措施减少锁冲突和死锁，包
括：
* 尽量使用较低的隔离级别；

*  精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会；
*  选择合理的事务大小，小事务发生锁冲突的几率也更小；

*  给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好
直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；

*  不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽
可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；

*  尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响；

*  不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；

*  对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。